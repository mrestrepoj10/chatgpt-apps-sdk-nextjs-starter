---
globs: app/api/**,**/route.ts
---

# API Route Patterns

## Route Handler Structure

### Basic Pattern

```typescript
import { NextRequest, NextResponse } from "next/server";

export async function GET(request: NextRequest) {
    // Handle GET request
    return NextResponse.json({ data: "response" });
}

export async function POST(request: NextRequest) {
    // Handle POST request
    const body = await request.json();
    return NextResponse.json({ success: true });
}

// Supported methods: GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS
```

## Bearer Token Authentication

### Standard Protected Route Pattern

```typescript
import { NextRequest, NextResponse } from "next/server";
import { validateScopes, verifyBearerToken } from "@/lib/supabase/auth";

export async function GET(request: NextRequest) {
    // Extract bearer token
    const authHeader = request.headers.get("authorization");

    if (!authHeader || !authHeader.startsWith("Bearer ")) {
        return NextResponse.json(
            { error: "Missing or invalid authorization header" },
            { status: 401 },
        );
    }

    const token = authHeader.substring(7); // Remove "Bearer " prefix

    // Verify token
    const user = await verifyBearerToken(token);

    if (!user) {
        return NextResponse.json(
            { error: "Invalid or expired token" },
            { status: 401 },
        );
    }

    // Validate required scopes
    const hasPermission = await validateScopes(token, ["profile:read"]);

    if (!hasPermission) {
        return NextResponse.json(
            { error: "Insufficient permissions" },
            { status: 403 },
        );
    }

    // Process request with authenticated user
    return NextResponse.json({ user });
}
```

## HTTP Status Codes

### Standard Response Codes

- **200 OK**: Successful GET request
- **201 Created**: Successful POST that creates a resource
- **204 No Content**: Successful request with no response body (DELETE)
- **400 Bad Request**: Invalid request body or parameters
- **401 Unauthorized**: Missing or invalid authentication
- **403 Forbidden**: Valid auth but insufficient permissions
- **404 Not Found**: Resource doesn't exist
- **500 Internal Server Error**: Unexpected server error

### Example Usage

```typescript
// Success
return NextResponse.json({ data }, { status: 200 });

// Created
return NextResponse.json({ id: newId }, { status: 201 });

// Bad request
return NextResponse.json(
    { error: "Invalid email format" },
    { status: 400 },
);

// Not found
return NextResponse.json(
    { error: "User not found" },
    { status: 404 },
);

// Server error
return NextResponse.json(
    { error: "Internal server error" },
    { status: 500 },
);
```

## Request Body Handling

### Parsing JSON

```typescript
export async function POST(request: NextRequest) {
    try {
        const body = await request.json();

        // Validate body structure
        if (!body.email || !body.password) {
            return NextResponse.json(
                { error: "Missing required fields" },
                { status: 400 },
            );
        }

        // Process body
        return NextResponse.json({ success: true });
    } catch (error) {
        return NextResponse.json(
            { error: "Invalid JSON" },
            { status: 400 },
        );
    }
}
```

### Parsing Form Data

```typescript
export async function POST(request: NextRequest) {
    const formData = await request.formData();
    const file = formData.get("file") as File;
    const name = formData.get("name") as string;

    // Process form data
}
```

### Parsing URL Search Params

```typescript
export async function GET(request: NextRequest) {
    const { searchParams } = new URL(request.url);
    const id = searchParams.get("id");
    const limit = parseInt(searchParams.get("limit") || "10");

    // Use query parameters
}
```

## Response Headers

### Setting Custom Headers

```typescript
const response = NextResponse.json({ data });
response.headers.set("X-Custom-Header", "value");
return response;
```

### CORS Headers

```typescript
const response = NextResponse.json({ data });
response.headers.set("Access-Control-Allow-Origin", "*");
response.headers.set("Access-Control-Allow-Methods", "GET,POST,PUT,DELETE");
response.headers.set(
    "Access-Control-Allow-Headers",
    "Content-Type,Authorization",
);
return response;
```

Note: CORS is already handled in [middleware.ts](mdc:middleware.ts) for most
routes.

## Error Handling

### Try-Catch Pattern

```typescript
export async function GET(request: NextRequest) {
    try {
        // Business logic
        const data = await fetchData();
        return NextResponse.json({ data });
    } catch (error) {
        console.error("Error in GET handler:", error);

        // Return generic error to client
        return NextResponse.json(
            { error: "An unexpected error occurred" },
            { status: 500 },
        );
    }
}
```

### Specific Error Handling

```typescript
try {
    // Operation
} catch (error) {
    if (error instanceof ZodError) {
        return NextResponse.json(
            { error: "Validation failed", details: error.errors },
            { status: 400 },
        );
    }

    if (error instanceof SupabaseError) {
        return NextResponse.json(
            { error: "Database error" },
            { status: 500 },
        );
    }

    throw error; // Re-throw unknown errors
}
```

## Database Operations

### Using Supabase Server Client

```typescript
import { createServerClient } from "@/lib/supabase/server";

export async function GET(request: NextRequest) {
    const supabase = createServerClient();

    const { data, error } = await supabase
        .from("table_name")
        .select("*")
        .eq("status", "active");

    if (error) {
        console.error("Database error:", error);
        return NextResponse.json(
            { error: "Failed to fetch data" },
            { status: 500 },
        );
    }

    return NextResponse.json({ data });
}
```

### Using Service Client (Admin Operations)

```typescript
import { createServiceClient } from "@/lib/supabase/server";

export async function POST(request: NextRequest) {
    // Verify user first with bearer token
    const user = await verifyBearerToken(token);

    // Use service client for admin operation
    const supabase = createServiceClient();

    const { error } = await supabase
        .from("admin_table")
        .insert({ user_id: user.id, data: "value" });

    // Handle result
}
```

## Dynamic Route Segments

### File Structure

```
app/api/users/[id]/route.ts
```

### Accessing Dynamic Segments

```typescript
export async function GET(
    request: NextRequest,
    { params }: { params: { id: string } },
) {
    const userId = params.id;

    // Use userId in logic
    return NextResponse.json({ userId });
}
```

### Multiple Dynamic Segments

```
app/api/posts/[postId]/comments/[commentId]/route.ts
```

```typescript
export async function GET(
    request: NextRequest,
    { params }: { params: { postId: string; commentId: string } },
) {
    const { postId, commentId } = params;
    // Use both IDs
}
```

## Validation with Zod

### Input Validation Pattern

```typescript
import { z } from "zod";

const userSchema = z.object({
    email: z.string().email(),
    password: z.string().min(6),
    age: z.number().int().positive().optional(),
});

export async function POST(request: NextRequest) {
    try {
        const body = await request.json();

        // Validate with Zod
        const validatedData = userSchema.parse(body);

        // Use validated data (type-safe)
        const { email, password, age } = validatedData;

        return NextResponse.json({ success: true });
    } catch (error) {
        if (error instanceof z.ZodError) {
            return NextResponse.json(
                { error: "Validation failed", details: error.errors },
                { status: 400 },
            );
        }

        return NextResponse.json(
            { error: "Internal error" },
            { status: 500 },
        );
    }
}
```

## Rate Limiting (Recommended for Production)

### Pattern for Rate Limiting

```typescript
// Consider adding a rate limiting library like @upstash/ratelimit

import { Ratelimit } from "@upstash/ratelimit";
import { Redis } from "@upstash/redis";

const ratelimit = new Ratelimit({
    redis: Redis.fromEnv(),
    limiter: Ratelimit.slidingWindow(10, "10 s"),
});

export async function POST(request: NextRequest) {
    const ip = request.ip ?? "127.0.0.1";
    const { success } = await ratelimit.limit(ip);

    if (!success) {
        return NextResponse.json(
            { error: "Too many requests" },
            { status: 429 },
        );
    }

    // Process request
}
```

## Streaming Responses

### Server-Sent Events (SSE)

```typescript
export async function GET(request: NextRequest) {
    const encoder = new TextEncoder();

    const stream = new ReadableStream({
        async start(controller) {
            // Send data chunks
            controller.enqueue(encoder.encode("data: Hello\n\n"));
            controller.enqueue(encoder.encode("data: World\n\n"));
            controller.close();
        },
    });

    return new Response(stream, {
        headers: {
            "Content-Type": "text/event-stream",
            "Cache-Control": "no-cache",
            "Connection": "keep-alive",
        },
    });
}
```

## Example: Complete Protected API Route

See [app/api/user/route.ts](mdc:app/api/user/route.ts) for a full example
implementing:

- Bearer token authentication
- Scope validation
- Error handling
- Proper HTTP status codes
- Type-safe responses
